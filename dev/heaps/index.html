<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Heaps · PureFun.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PureFun.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Purely Functional Data Structures, in Julia</a></li><li><a class="tocitem" href="../lists/">Lists</a></li><li><a class="tocitem" href="../queues/">Queues/Deques</a></li><li class="is-active"><a class="tocitem" href>Heaps</a><ul class="internal"><li><a class="tocitem" href="#Pairing.Heap-\\S{5.5}"><span><code>Pairing.Heap</code> <span>$\S{5.5}$</span></span></a></li><li><a class="tocitem" href="#SkewBinomial.Heap-\\S{9.3.2}"><span><code>SkewBinomial.Heap</code> <span>$\S{9.3.2}$</span></span></a></li><li><a class="tocitem" href="#BootstrappedSkewBinomial.Heap-\\S{10.2.2}"><span><code>BootstrappedSkewBinomial.Heap</code> <span>$\S{10.2.2}$</span></span></a></li><li><a class="tocitem" href="#Function-reference"><span>Function reference</span></a></li></ul></li><li><a class="tocitem" href="../dicts/">Dictionaries</a></li><li><a class="tocitem" href="../sets/">Sets</a></li><li><a class="tocitem" href="../generated/streams/">Streams</a></li><li><a class="tocitem" href="../contiguous/">Small size optimizations</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/estimating-pi/">Estimating π</a></li><li><a class="tocitem" href="../generated/balanced-parentheses/">Balanced Parentheses</a></li><li><a class="tocitem" href="../generated/taxicab/">Ramanujan (taxicab) numbers</a></li><li><a class="tocitem" href="../generated/suffixes/">Generating Suffixes</a></li><li><a class="tocitem" href="../generated/hamt/">Hash Array Mapped Tries</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Heaps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Heaps</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tarakc02/PureFun.jl/blob/main//docs/src/heaps.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Heaps"><a class="docs-heading-anchor" href="#Heaps">Heaps</a><a id="Heaps-1"></a><a class="docs-heading-anchor-permalink" href="#Heaps" title="Permalink"></a></h1><p>Heaps, also known as <em>priority queues</em>, provide efficient access to the <em>minimum element</em> in a collection, and an efficient <em>delete-the-minimum</em> operation as well as a <em>merge</em> operation that takes two heaps and returns one.</p><p>We define &quot;minimum&quot; with respect to an <a href="https://docs.julialang.org/en/v1/base/sort/#Alternate-orderings"><code>Ordering</code></a> type parameter, so heaps are parameterized by both the element type and the ordering.</p><p>Heaps in PureFun.jl inherit from the abstract type <code>PureFun.PFHeap</code>. The full interface:</p><ul><li><code>push(xs, x)</code> returns a new heap containing <code>x</code> as well as all elements in <code>xs</code></li><li><code>minimum</code></li><li><code>delete_min</code></li><li><code>merge</code></li></ul><p>Heaps iterate in sorted order, so <code>first(xs::Heap) == minimum(xs)</code></p><p>If not specified, the ordering for a heap defaults to <code>Base.Order.Forward</code>. Heap constructors are like the constructors for lists and queues, but take the ordering as an additional optional argument.</p><h2 id="Pairing.Heap-\\S{5.5}"><a class="docs-heading-anchor" href="#Pairing.Heap-\\S{5.5}"><code>Pairing.Heap</code> <span>$\S{5.5}$</span></a><a id="Pairing.Heap-\\S{5.5}-1"></a><a class="docs-heading-anchor-permalink" href="#Pairing.Heap-\\S{5.5}" title="Permalink"></a></h2><p>The <code>Pairing.Heap</code> is very fast, but requires occasional expensive rebalancing operations to maintain efficient access to the minimum element, and should be used when the data structure has only a single logical future (see the discussion in <a href="../queues/#Queues">Queues</a> for more information about this concept). Otherwise, try the <a href="#PureFun.SkewBinomial.Heap"><code>SkewBinomial.Heap</code></a> or the <a href="#PureFun.BootstrappedSkewBinomial.Heap"><code>BootstrappedSkewBinomial.Heap</code></a></p><article class="docstring"><header><a class="docstring-binding" id="PureFun.Pairing.Heap" href="#PureFun.Pairing.Heap"><code>PureFun.Pairing.Heap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pairing.Heap{T}(o::Base.Order.Ordering=Base.Order.Forward)
Pairing.Heap(iter, ord=Base.Order.Forward)</code></pre><p>Pairing heaps (<span>$\S{5.5}$</span>):</p><blockquote><p>... are one of those data structures that drive theoreticians crazy. On the one hand, pairing heaps are simple to implement and perform extremely well in practice. On the other hand, they have resisted analysis for over ten years!</p></blockquote><p><code>push</code>, <code>merge</code>, and <code>minimum</code> all run in <span>$\mathcal{O}(1)$</span> worst-case time. <code>delete_min</code> can take <span>$\mathcal{O}(n)$</span> time in the worst-case. However, it has been proven that the amortized time required by <code>delete_min</code> is no worse than <span>$\mathcal{O}(\log{}n)$</span>, and there is an open conjecture that it is in fact <span>$\mathcal{O}(1)$</span>. The amortized bounds here do <em>not</em> apply in persistent settings. For heaps suited to persistent use-cases, see <a href="#PureFun.SkewBinomial.Heap"><code>PureFun.SkewBinomial.Heap</code></a> and <a href="#PureFun.BootstrappedSkewBinomial.Heap"><code>PureFun.BootstrappedSkewBinomial.Heap</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PureFun, PureFun.Pairing
julia&gt; xs = [5, 3, 1, 4, 2];

julia&gt; Pairing.Heap(xs)
5-element PureFun.Pairing.NonEmpty{Int64, Base.Order.ForwardOrdering}
1
2
3
4
5


julia&gt; Pairing.Heap(xs, Base.Order.Reverse)
5-element PureFun.Pairing.NonEmpty{Int64, Base.Order.ReverseOrdering{Base.Order.ForwardOrdering}}
5
4
3
2
1


julia&gt; empty = Pairing.Heap{Int}(Base.Order.Reverse);
julia&gt; reduce(push, xs, init=empty)
5-element PureFun.Pairing.NonEmpty{Int64, Base.Order.ReverseOrdering{Base.Order.ForwardOrdering}}
5
4
3
2
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/heaps/pairing-heap.jl#L21-L75">source</a></section></article><h2 id="SkewBinomial.Heap-\\S{9.3.2}"><a class="docs-heading-anchor" href="#SkewBinomial.Heap-\\S{9.3.2}"><code>SkewBinomial.Heap</code> <span>$\S{9.3.2}$</span></a><a id="SkewBinomial.Heap-\\S{9.3.2}-1"></a><a class="docs-heading-anchor-permalink" href="#SkewBinomial.Heap-\\S{9.3.2}" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PureFun.SkewBinomial.Heap" href="#PureFun.SkewBinomial.Heap"><code>PureFun.SkewBinomial.Heap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SkewBinomial.Heap{T}(o=Base.Order.Forward)
SkewBinomial.Heap(iter, o=Base.Order.Forward)</code></pre><p>The Skew Binomial Heap <span>$\S{9.3.2}$</span> is a twist on the <a href="https://en.wikipedia.org/wiki/Binomial_heap">Binomial Heap</a>: by basing tree sizes on skew-binary (rather than binary) numbers, pushing a new element into a skew binomial heap is worst-case <span>$\mathcal{O}(1)$</span> (as opposed to <span>$\mathcal{O}(\log{}n)$</span> for binomial heaps). <code>merge</code>, <code>delete_min</code>, and <code>minimum</code> are worst-case <span>$\mathcal{O}(\log{}n)$</span>. See also <a href="#PureFun.BootstrappedSkewBinomial.Heap"><code>PureFun.BootstrappedSkewBinomial.Heap</code></a>, which uses structural abstraction to improve <code>minimum</code> and <code>merge</code> to worst-case <span>$\mathcal{O}(1)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/heaps/skew-binomial-heap.jl#L21-L35">source</a></section></article><h2 id="BootstrappedSkewBinomial.Heap-\\S{10.2.2}"><a class="docs-heading-anchor" href="#BootstrappedSkewBinomial.Heap-\\S{10.2.2}"><code>BootstrappedSkewBinomial.Heap</code> <span>$\S{10.2.2}$</span></a><a id="BootstrappedSkewBinomial.Heap-\\S{10.2.2}-1"></a><a class="docs-heading-anchor-permalink" href="#BootstrappedSkewBinomial.Heap-\\S{10.2.2}" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PureFun.BootstrappedSkewBinomial.Heap" href="#PureFun.BootstrappedSkewBinomial.Heap"><code>PureFun.BootstrappedSkewBinomial.Heap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BootstrappedSkewBinomial.Heap{T}(ord=Base.Order.Forward)
BootstrappedSkewBinomial.Heap(iter, ord=Base.Order.Forward)</code></pre><p>Section <span>$\S{10.2.2}$</span> of <em>Purely Functional Data Structures</em> demonstrates how to use structural abstraction to take a heap implementation with <span>$\mathcal{O}(1)$</span> <code>push</code> and improve the running time of <code>merge</code> and <code>minimum</code> to <span>$\mathcal{O}(1)$</span>. The <code>BootStrappedSkewBinomial.Heap</code> uses the technique on the <a href="#PureFun.SkewBinomial.Heap"><code>PureFun.SkewBinomial.Heap</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/heaps/bootstrapped-heap.jl#L28-L38">source</a></section></article><h2 id="Function-reference"><a class="docs-heading-anchor" href="#Function-reference">Function reference</a><a id="Function-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Function-reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.minimum-Tuple{PureFun.PFHeap}" href="#Base.minimum-Tuple{PureFun.PFHeap}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum(xs::PFHeap)</code></pre><p>Return the smallest element in <code>xs</code>, according to its ordering. Since heaps iterate in order, this is identical to <code>first</code> for heaps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/pfheap-interface.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PureFun.delete_min" href="#PureFun.delete_min"><code>PureFun.delete_min</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete_min(xs::PFHeap)</code></pre><p>return a new heap that is the result of deleting the minimum element from <code>xs</code>, according to the ordering of <code>xs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/pfheap-interface.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticArrays.push-Tuple{PureFun.PFHeap, Any}" href="#StaticArrays.push-Tuple{PureFun.PFHeap, Any}"><code>StaticArrays.push</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">push(xs::PFHeap, x)</code></pre><p>Return the <code>PFHeap</code> that results from adding <code>x</code> to the collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/pfheap-interface.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge-Tuple{PureFun.PFHeap, PureFun.PFHeap}" href="#Base.merge-Tuple{PureFun.PFHeap, PureFun.PFHeap}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge(xs::PFHeap, ys::PFHeap)</code></pre><p>Return a new heap with the merged contents of <code>xs</code> and <code>ys</code> (<code>xs</code> and <code>ys</code> must have the same ordering)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/pfheap-interface.jl#L47-L52">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../queues/">« Queues/Deques</a><a class="docs-footer-nextpage" href="../dicts/">Dictionaries »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 12 December 2022 23:55">Monday 12 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
