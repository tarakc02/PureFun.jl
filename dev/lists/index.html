<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lists · PureFun.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PureFun.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Purely Functional Data Structures, in Julia</a></li><li class="is-active"><a class="tocitem" href>Lists</a><ul class="internal"><li><a class="tocitem" href="#Linked.List-(\\S{2.1})"><span><code>Linked.List</code> (<span>$\S{2.1}$</span>)</span></a></li><li><a class="tocitem" href="#RandomAccess.List-(\\S{9.3.1})"><span><code>RandomAccess.List</code> (<span>$\S{9.3.1}$</span>)</span></a></li><li><a class="tocitem" href="#Catenable.List-(\\S{10.2.1})"><span><code>Catenable.List</code> (<span>$\S{10.2.1}$</span>)</span></a></li><li><a class="tocitem" href="#VectorCopy.List:-an-immutable-wrapper-for-Base.Vector"><span><code>VectorCopy.List</code>: an immutable wrapper for <code>Base.Vector</code></span></a></li><li><a class="tocitem" href="#CPU-cache-friendly-lists:-Chunky.@list"><span>CPU-cache friendly lists: <code>Chunky.@list</code></span></a></li><li><a class="tocitem" href="#Custom-double-ended-queue:-\\S{5.2}-(excercise-5.1)"><span>Custom double-ended queue: <span>$\S{5.2}$</span> (excercise 5.1)</span></a></li><li><a class="tocitem" href="#Function-reference"><span>Function reference</span></a></li></ul></li><li><a class="tocitem" href="../queues/">Queues/Deques</a></li><li><a class="tocitem" href="../heaps/">Heaps</a></li><li><a class="tocitem" href="../dicts/">Dictionaries</a></li><li><a class="tocitem" href="../sets/">Sets</a></li><li><a class="tocitem" href="../generated/streams/">Streams</a></li><li><a class="tocitem" href="../contiguous/">Small size optimizations</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/balanced-parentheses/">Balanced Parentheses</a></li><li><a class="tocitem" href="../generated/taxicab/">Ramanujan (taxicab) numbers</a></li><li><a class="tocitem" href="../generated/suffixes/">Generating Suffixes</a></li><li><a class="tocitem" href="../generated/hamt/">Hash Array Mapped Tries</a></li><li><a class="tocitem" href="../generated/estimating-pi/">Estimating π</a></li><li><a class="tocitem" href="../generated/data-parallelism/">Data parallelism</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Lists</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lists</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tarakc02/PureFun.jl/blob/main//docs/src/lists.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Lists"><a class="docs-heading-anchor" href="#Lists">Lists</a><a id="Lists-1"></a><a class="docs-heading-anchor-permalink" href="#Lists" title="Permalink"></a></h1><p>Provide efficient access to the front element, and can efficiently add and remove elements from the front. Sometimes also called a &quot;stack.&quot; Primary operations:</p><ul><li><code>first(xs)</code>: get the first element of <code>xs</code></li><li><code>popfirst(xs)</code>: returns a new list that looks like <code>xs</code> but with the first element removed</li><li><code>pushfirst(xs, x)</code>: returns a new list with <code>x</code> added to the front of <code>xs</code>. The infix operator <code>⇀</code> (pronounced <code>\rightharpoonup</code>) is often more convenient. Note that it is right-associative, so <code>x ⇀ y ⇀ zs</code> is equivalent to <code>pushfirst(pushfirst(zs, y), x)</code></li></ul><p>Additionally, PureFun.jl implements default implementations of a variety of <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.AbstractVector">Abstract Vector</a>-like methods for list types, though they are not necessarily efficient. All of these functions have similar meanings to their mutating (with a <code>!</code> at the end of the function name) counterparts in <code>Base</code>. When these functions are already present in <a href="https://juliaarrays.github.io/StaticArrays.jl/stable/">StaticArrays.jl</a>, PureFun.jl just adds methods to the existing functions.</p><ul><li><code>reverse</code></li><li><code>insert</code></li><li><code>getindex</code> (<code>xs[i]</code> to get the i-th element of <code>xs</code>)</li><li><code>setindex</code> (help wanted: nice syntax for non-mutating <code>setindex</code>)</li><li><code>append</code> (use the infix notation <code>xs ⧺ ys</code> to append <code>ys</code> to the end of <code>xs</code>)</li></ul><p>Lists iterate in <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">LIFO</a> order, and work with a variety of built-in <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher-order functions</a>:</p><ul><li>eager versions of <code>map</code>, <code>filter</code>, <code>accumulate</code></li><li><code>(map)foldl</code>, <code>(map)foldr</code>, <code>(map)reduce</code></li></ul><p>All of the lists types provide the same functionality and interface, but different implementations are optimized for different use-cases and types of operations. For example, getting or setting an index in a linked list usually takes <span>$\mathcal{O}(n)$</span> time, but <code>PureFun.RandomAccess.List</code> provides indexing operations that take <span>$\mathcal{O}(\log{_2}n)$</span>. All of the list implementations in PureFun.jl inherit from the abstract type <code>PureFun.PFList</code>. Complexities presented below are worst-case, unless stated otherwise.</p><h2 id="Linked.List-(\\S{2.1})"><a class="docs-heading-anchor" href="#Linked.List-(\\S{2.1})"><code>Linked.List</code> (<span>$\S{2.1}$</span>)</a><a id="Linked.List-(\\S{2.1})-1"></a><a class="docs-heading-anchor-permalink" href="#Linked.List-(\\S{2.1})" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PureFun.Linked.List" href="#PureFun.Linked.List"><code>PureFun.Linked.List</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Linked.List{T}()
Linked.List(iter)</code></pre><p>The <code>Linked.List</code> (<span>$\S{2.1}$</span>) is the simplest of the list types, and the fastest for the primary operations, which are all <span>$\mathcal{O}(1)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PureFun, PureFun.Linked
julia&gt; l = Linked.List(1:3)
3-element PureFun.Linked.NonEmpty{Int64}
1
2
3


julia&gt; m = pushfirst(l, 10)
4-element PureFun.Linked.NonEmpty{Int64}
10
1
2
3


julia&gt; first(l)
1

julia&gt; first(m)
10

julia&gt; popfirst(m) == l
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/lists-streams/list.jl#L25-L59">source</a></section></article><h2 id="RandomAccess.List-(\\S{9.3.1})"><a class="docs-heading-anchor" href="#RandomAccess.List-(\\S{9.3.1})"><code>RandomAccess.List</code> (<span>$\S{9.3.1}$</span>)</a><a id="RandomAccess.List-(\\S{9.3.1})-1"></a><a class="docs-heading-anchor-permalink" href="#RandomAccess.List-(\\S{9.3.1})" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PureFun.RandomAccess.List" href="#PureFun.RandomAccess.List"><code>PureFun.RandomAccess.List</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomAccess.List{T}()
RandomAccess.List(iter)</code></pre><p>A <code>RandomAccess.List</code> (<span>$\S{9.3.2}$</span>) adds efficient (<span>$\mathcal{O}(\log{}n)$</span>) indexing (<code>getindex</code> and <code>setindex</code>) operations to the <span>$\mathcal{O}(1)$</span> primary operations. The implementation stores elements in complete binary trees representing digits in the <a href="https://en.wikipedia.org/wiki/Skew_binary_number_system">skew binary number system</a>, as described in <a href="http://arh68.com/software/2015/05/19/skew-binary-random-access-lists.html">this blog post</a>.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; rl = PureFun.RandomAccess.List(1:1_000)
1
2
3
4
5
6
7
...


julia&gt; rl[937]
937</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/lists-streams/skew-binary-ral.jl#L63-L91">source</a></section></article><h2 id="Catenable.List-(\\S{10.2.1})"><a class="docs-heading-anchor" href="#Catenable.List-(\\S{10.2.1})"><code>Catenable.List</code> (<span>$\S{10.2.1}$</span>)</a><a id="Catenable.List-(\\S{10.2.1})-1"></a><a class="docs-heading-anchor-permalink" href="#Catenable.List-(\\S{10.2.1})" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PureFun.Catenable.List" href="#PureFun.Catenable.List"><code>PureFun.Catenable.List</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Catenable.List{T}()
Catenable.List(iter)</code></pre><p>A <code>Catenable.List</code> (<span>$\S{10.2.1}$</span>) supports the usual list operations, but unlike the <code>Linked.List</code> you can append two catenable lists in constant time. These lists are presented in section 10.2.1 of the book, as an example of data-structural bootstrapping. In addition to list functions, catenable lists also support <code>push</code>. Catenable lists work by maintaining the <code>head</code> element plus a queue of catenable lists. Each element of this queue is suspended. <code>first</code> takes constant time, while <code>pushfirst</code>, <code>popfirst</code>, <code>push</code>, and <code>⧺</code> require <em>amortized</em> (rather than worst-case) constant time.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; a = PureFun.Catenable.List(1:3);

julia&gt; b = PureFun.Catenable.List(4:5);

julia&gt; a ⧺ b
1
2
7
4
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/lists-streams/catenable-list.jl#L59-L85">source</a></section></article><h2 id="VectorCopy.List:-an-immutable-wrapper-for-Base.Vector"><a class="docs-heading-anchor" href="#VectorCopy.List:-an-immutable-wrapper-for-Base.Vector"><code>VectorCopy.List</code>: an immutable wrapper for <code>Base.Vector</code></a><a id="VectorCopy.List:-an-immutable-wrapper-for-Base.Vector-1"></a><a class="docs-heading-anchor-permalink" href="#VectorCopy.List:-an-immutable-wrapper-for-Base.Vector" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PureFun.VectorCopy.List" href="#PureFun.VectorCopy.List"><code>PureFun.VectorCopy.List</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorCopy.List{T}()
VectorCopy.List(iter)</code></pre><p><code>VectorCopy.List</code> is a wrapper around <code>Base.Vector</code> with copy-on-write semantics. <code>pushfirst</code> is <span>$\mathcal{O}(n)$</span>, but iteration and indexing are very fast. Useful for small lists, or for lists that are traversed frequently relative to how often they are modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/lists-streams/vector-list.jl#L5-L14">source</a></section></article><h2 id="CPU-cache-friendly-lists:-Chunky.@list"><a class="docs-heading-anchor" href="#CPU-cache-friendly-lists:-Chunky.@list">CPU-cache friendly lists: <code>Chunky.@list</code></a><a id="CPU-cache-friendly-lists:-Chunky.@list-1"></a><a class="docs-heading-anchor-permalink" href="#CPU-cache-friendly-lists:-Chunky.@list" title="Permalink"></a></h2><p>Pointer-based data structures are at a disadvantage performance-wise when compared to arrays and vectors. Memory accesses are high-latency operations, so that observed performance will be determined by the number of cache misses regardless of the on-paper complexity guarantees of an algorithm. The <code>VectorCopy.List</code> gets around this issue by storing adjacent list values physically close to each other in contiguous memory, but write operations require allocating <span>$\mathcal{O}(n)$</span> memory, which quickly becomes prohibitive. The <a href="https://en.wikipedia.org/wiki/Unrolled_linked_list">unrolled linked list</a> strikes a compromise between the two extremes by storing chunks of values together in each list cell. <code>PureFun.Chunky.@list</code> converts any list type to a &quot;chunky&quot; version, using one of the chunk types provided by <a href="../contiguous/#PureFun.Contiguous"><code>PureFun.Contiguous</code></a>:</p><ul><li><a href="../contiguous/#PureFun.Contiguous.StaticChunk"><code>Contiguous.StaticChunk{N}</code></a>: Backed by <code>StaticArrays.SVector</code></li><li><a href="../contiguous/#PureFun.Contiguous.VectorChunk"><code>Contiguous.VectorChunk{N}</code></a>: Backed by <code>Base.Vector</code></li></ul><article class="docstring"><header><a class="docstring-binding" id="PureFun.Chunky.@list" href="#PureFun.Chunky.@list"><code>PureFun.Chunky.@list</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">Chunky.@list Name ListType ChunkType</code></pre><p>Creates a new list type (implements all list functions and inherits from <code>PureFun.PFList</code>) by assembling a list (of type <code>ListType</code>) of <em>chunks</em> (of type <code>ChunkType</code>). Assuming <code>ChunkType</code> stores chunk elements contiguously, the resulting list will have improved iteration performance. <a href="../contiguous/#PureFun.Contiguous.VectorChunk"><code>PureFun.Contiguous.VectorChunk</code></a> and <a href="../contiguous/#PureFun.Contiguous.StaticChunk"><code>PureFun.Contiguous.StaticChunk</code></a> implement the chunk type and can be used in chunky lists.</p><p><strong>Examples</strong></p><p>This example creates a chunky list called <code>ChunkyList</code> consisting of (up to) 16-element chunks stored contiguously in memory as static arrays, linked together via a linked list. The resulting list has the same interface as any other list type in PureFun.jl:</p><pre><code class="language-julia-repl hljs">julia&gt; using PureFun, PureFun.Linked, PureFun.Chunky, PureFun.Contiguous

julia&gt; Chunky.@list CList list=Linked.List chunk=Contiguous.StaticChunk{16}

julia&gt; clist = CList(1:100)
100-element CList{Int64}
1
2
3
4
5
6
7
...

julia&gt; clist[18]
18

julia&gt; mapfoldl(sqrt, +, clist)
671.4629471031477</code></pre><p>Similarly, the following example uses <a href="#PureFun.RandomAccess.List"><code>PureFun.RandomAccess.List</code></a>s and chunks of <code>Base.Vector</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using PureFun, PureFun.RandomAccess, PureFun.Chunky, PureFun.Contiguous

julia&gt; Chunky.@list CRList list=RandomAccess.List chunk=Contiguous.VectorChunk{256}

julia&gt; em = CRList{Float64}()
0-element CRList{Float64}


julia&gt; 1.0 ⇀ 2.0 ⇀ em
2-element CRList{Float64}
1.0
2.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/lists-streams/chunky2.jl#L15-L75">source</a></section></article><p>For more on cache-friendly data structures and the role of cache misses on performance:</p><ul><li><a href="https://gameprogrammingpatterns.com/data-locality.html">Data Locality</a></li><li><a href="https://youtu.be/2EWejmkKlxs">Going nowhere faster</a> </li><li><a href="http://igoro.com/archive/gallery-of-processor-cache-effects/">Gallery of processor cache effects</a></li></ul><h2 id="Custom-double-ended-queue:-\\S{5.2}-(excercise-5.1)"><a class="docs-heading-anchor" href="#Custom-double-ended-queue:-\\S{5.2}-(excercise-5.1)">Custom double-ended queue: <span>$\S{5.2}$</span> (excercise 5.1)</a><a id="Custom-double-ended-queue:-\\S{5.2}-(excercise-5.1)-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-double-ended-queue:-\\S{5.2}-(excercise-5.1)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PureFun.Batched.@deque" href="#PureFun.Batched.@deque"><code>PureFun.Batched.@deque</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">Batched.@deque Name ListType</code></pre><p>Deques are like lists but with symmetric efficient operations on the front (<code>pushfirst</code>, <code>popfirst</code>, <code>first</code>) and the back (<code>push</code>, <code>pop</code>, <code>last</code>). The <code>Batched.@deque</code> <a href="https://ocaml.org/docs/functors">functor</a> takes any existing list implementation (<code>ListType</code>), and makes it double-ended. The <code>Batched.@deque</code> works by batching occasional reversals (which are <span>$\mathcal{O}(n)$</span>) so that all operations require <em>amortized</em> constant time.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Batched.@deque Deque PureFun.Linked.List

julia&gt; d = Deque{Int}()
0-element Deque{Int64}


julia&gt; 1 ⇀ 2 ⇀ 3 ⇀ d
3-element Deque{Int64}
1
2
3


julia&gt; alpha = Deque(&#39;a&#39;:&#39;z&#39;)
26-element Deque{Char}
a
b
c
d
e
f
g
...

julia&gt; first(alpha), last(alpha)
(&#39;a&#39;, &#39;z&#39;)

julia&gt; alpha |&gt; pop |&gt; last
&#39;y&#39;: ASCII/Unicode U+0079 (category Ll: Letter, lowercase)

julia&gt; alpha |&gt; popfirst |&gt; first
&#39;b&#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/queues/batchedqueue2.jl#L10-L57">source</a></section></article><h2 id="Function-reference"><a class="docs-heading-anchor" href="#Function-reference">Function reference</a><a id="Function-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Function-reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StaticArrays.pushfirst-Tuple{PureFun.PFList, Any}" href="#StaticArrays.pushfirst-Tuple{PureFun.PFList, Any}"><code>StaticArrays.pushfirst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cons(x, xs::PFList)
pushfirst(xs::PFList, x)
x ⇀ xs</code></pre><p>Return the <code>PFList</code> that results from adding <code>x</code> to the front of <code>xs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/pflist-interface.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticArrays.popfirst-Tuple{Union{PureFun.PFList{T}, PureFun.PFQueue{T}, PureFun.PFStream{T}} where T}" href="#StaticArrays.popfirst-Tuple{Union{PureFun.PFList{T}, PureFun.PFQueue{T}, PureFun.PFStream{T}} where T}"><code>StaticArrays.popfirst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">popfirst(xs)</code></pre><p>Return the collection <code>xs</code> without its first element (without modifying <code>xs</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/interfaces.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PureFun.append" href="#PureFun.append"><code>PureFun.append</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">append(xs, ys)
xs ⧺ ys</code></pre><p>Concatenate two <code>PFLists</code>.</p><pre><code class="language- hljs">julia&gt; l1 = PureFun.Linked.List(1:3);

julia&gt; l2 = PureFun.Linked.List(4:6);

julia&gt; l1 ⧺ l2
1
2
3
4
5
6
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/pflist-interface.jl#L51-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticArrays.insert-Tuple{PureFun.PFList, Any, Any}" href="#StaticArrays.insert-Tuple{PureFun.PFList, Any, Any}"><code>StaticArrays.insert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insert(list::PFList, ix, v)</code></pre><p>Return a new list with the element <code>v</code> inserted at index <code>ix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/pflist-interface.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex-Tuple{PureFun.PFList, Any, Any}" href="#Base.setindex-Tuple{PureFun.PFList, Any, Any}"><code>Base.setindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex(l::PFList, newval, ind)</code></pre><p>Return a new list with the value at index <code>ind</code> set to <code>newval</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PureFun, PureFun.RandomAccess

julia&gt; l = RandomAccess.List(1:10)
10-element PureFun.RandomAccess.List{Int64}
1
2
3
4
5
6
7
...

julia&gt; setindex(l, 99, 4)
10-element PureFun.RandomAccess.List{Int64}
1
2
3
99
5
6
7
...
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/pflist-interface.jl#L80-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PureFun.halfish" href="#PureFun.halfish"><code>PureFun.halfish</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">halfish(xs)</code></pre><p>Split <code>xs</code> <em>roughly</em> in half, and return the two halves as a tuple (front, back).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&lt; using PureFun
julia&gt; l = PureFun.Linked.List(1:100)
100-element PureFun.Linked.NonEmpty{Int64}
1
2
3
4
5
6
7
...

julia&gt; halves = halfish(l)
(1, 2, 3, 4, 5, ..., 51, 52, 53, 54, 55, ...)

julia&gt; length(halves[1]), length(halves[2])
(50, 50)

julia&gt; halves[2]
50-element PureFun.Linked.NonEmpty{Int64}
51
52
53
54
55
56
57
...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tarakc02/PureFun.jl/blob/main//src/pflist-interface.jl#L169-L208">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Purely Functional Data Structures, in Julia</a><a class="docs-footer-nextpage" href="../queues/">Queues/Deques »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 9 September 2023 00:33">Saturday 9 September 2023</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
