<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hash Array Mapped Tries · PureFun.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PureFun.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Purely Functional Data Structures, in Julia</a></li><li><a class="tocitem" href="../../lists/">Lists</a></li><li><a class="tocitem" href="../../queues/">Queues/Deques</a></li><li><a class="tocitem" href="../../heaps/">Heaps</a></li><li><a class="tocitem" href="../../dicts/">Dictionaries</a></li><li><a class="tocitem" href="../../sets/">Sets</a></li><li><a class="tocitem" href="../streams/">Streams</a></li><li><a class="tocitem" href="../../contiguous/">Small size optimizations</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../balanced-parentheses/">Balanced Parentheses</a></li><li><a class="tocitem" href="../taxicab/">Ramanujan (taxicab) numbers</a></li><li><a class="tocitem" href="../suffixes/">Generating Suffixes</a></li><li class="is-active"><a class="tocitem" href>Hash Array Mapped Tries</a><ul class="internal"><li><a class="tocitem" href="#Setup:-testing-dictionary-implementations-for-correctness"><span>Setup: testing dictionary implementations for correctness</span></a></li><li><a class="tocitem" href="#Introduction:-hashmaps"><span>Introduction: hashmaps</span></a></li><li><a class="tocitem" href="#Improving-on-\\mathcal{O}(\\log_{2}n)"><span>Improving on <span>$\mathcal{O}(\log_{2}n)$</span></span></a></li><li><a class="tocitem" href="#Tries:-chaining-together-smaller-dictionaries"><span>Tries: chaining together smaller dictionaries</span></a></li><li><a class="tocitem" href="#biterate:-iterating-over-sequences-of-bits"><span><code>biterate</code>: iterating over sequences of bits</span></a></li><li><a class="tocitem" href="#References-and-further-reading"><span>References and further reading</span></a></li></ul></li><li><a class="tocitem" href="../estimating-pi/">Estimating π</a></li><li><a class="tocitem" href="../data-parallelism/">Data parallelism</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Hash Array Mapped Tries</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hash Array Mapped Tries</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tarakc02/PureFun.jl/blob/main/docs/src/hamt.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia hljs">using PureFun, PureFun.HashMaps, PureFun.Tries
using Test, BenchmarkTools, Random</code></pre><h2 id="Setup:-testing-dictionary-implementations-for-correctness"><a class="docs-heading-anchor" href="#Setup:-testing-dictionary-implementations-for-correctness">Setup: testing dictionary implementations for correctness</a><a id="Setup:-testing-dictionary-implementations-for-correctness-1"></a><a class="docs-heading-anchor-permalink" href="#Setup:-testing-dictionary-implementations-for-correctness" title="Permalink"></a></h2><p>In the following essay, we&#39;ll construct a variety of immutable dictionary types. We start with some basic tests to convince ourselves that the dictionaries work as expected</p><pre><code class="language-julia hljs">nstrings(n) = collect(randstring(rand(8:15)) for _ in 1:n)
randpairs(n) = (k =&gt; v for (k,v) in zip(nstrings(n), rand(Int, n)))

function test_dicttype(D)
    @testset &quot;basic tests for $D&quot; begin

        kvs = randpairs(100)
        testdict = D(kvs)

        @test all(testdict[p.first] == p.second for p in kvs)
        @test empty(testdict) |&gt; isempty

        e = D{String,String}()
        @test isempty(e)

        d1 = setindex(e, &quot;world&quot;, &quot;hello&quot;)
        @test length(d1) == 1
        @test d1[&quot;hello&quot;] == &quot;world&quot;
    end
    return nothing
end;</code></pre><p>Microbenchmarks will be noisy when run on the documentation server. In the essay below, instead of running the benchmarking code, I&#39;ll report my results from running the code locally. But I&#39;m including the benchmarking code used here for those who want to follow along. Note that actual performance of any dictionary will depend on the size and distribution of keys, the tests here are not meant to be comprehensive, but are meant to illustrate the concepts and tradeoffs explored below.</p><pre><code class="language-julia hljs">function bench_dicttype(D, n)
    kvs = randpairs(n)
    testdict = D(kvs)
    ks = collect(kv.first for kv in kvs)
    search_hit  = @benchmark $testdict[k] setup=k=rand($ks)
    search_miss = @benchmark get($testdict, &quot;nonexisting key&quot;, -1)
    (size = n,
     search_hit_ns  = round(Int, median(search_hit).time),
     search_miss_ns = round(Int, median(search_miss).time))
end;</code></pre><p>As a reference point, we see how <code>Base.Dict</code> looks:</p><pre><code class="language-julia hljs">julia&gt; bench_dicttype(Dict, 10)
(size = 10, search_hit_ns = 12, search_miss_ns = 11)

julia&gt; bench_dicttype(Dict, 100)
(size = 100, search_hit_ns = 11, search_miss_ns = 11)

julia&gt; bench_dicttype(Dict, 100_000)
(size = 100000, search_hit_ns = 12, search_miss_ns = 11)

julia&gt; bench_dicttype(Dict, 1_000_000)
(size = 1000000, search_hit_ns = 12, search_miss_ns = 18)</code></pre><h2 id="Introduction:-hashmaps"><a class="docs-heading-anchor" href="#Introduction:-hashmaps">Introduction: hashmaps</a><a id="Introduction:-hashmaps-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction:-hashmaps" title="Permalink"></a></h2><p>Exercise 10.11 of <em>Purely Functional Data Structures</em> describes a <em>hashmap</em> (or hashtable) as a nested dictionary, an outer dictionary that maps <em>approximate</em> keys to inner dictionaries keyed by <em>exact</em> keys. We complete the definition by specifying a <em>hash</em> function that converts exact keys to approximate keys. For example, in C++ the <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a> uses <code>std::hash</code> as a hash function that maps input keys to integers, an array as the <em>approximate</em> dictionary (think of an array as a dictionary with integer keys), and a linked list as the <em>exact</em> dictionary.</p><p><a href="../../dicts/#PureFun.HashMaps.@hashmap"><code>PureFun.HashMaps.@hashmap</code></a> constructs new dictionary types by assembling hashmaps from specified components:</p><pre><code class="language-julia hljs">const RBDict = PureFun.RedBlack.RBDict{Base.Order.ForwardOrdering}

@hashmap(RedBlackHashMap,
         approx   = RBDict,
         exact    = PureFun.Association.List,
         hashfunc = hash)</code></pre><p><code>hashfunc</code> is optional, and is set to <a href="https://docs.julialang.org/en/v1/base/base/#Base.hash"><code>Base.hash</code></a> by default.<sup class="footnote-reference"><a id="citeref-hashfuncs" href="#footnote-hashfuncs">[hashfuncs]</a></sup></p><p>We now test and benchmark <code>RedBlackHashMap</code>:</p><pre><code class="language-julia hljs">test_dicttype(RedBlackHashMap)</code></pre><pre><code class="nohighlight hljs">Test Summary:                                   | Pass  Total  Time
basic tests for Main.var&quot;##319&quot;.RedBlackHashMap |    5      5  0.9s
</code></pre><p>Though the resulting benchmarks are still impressive, we can see that search times slow down as the collection gets larger.</p><pre><code class="language-julia hljs">julia&gt; bench_dicttype(RedBlackHashMap, 10)
(size = 10, search_hit_ns = 31, search_miss_ns = 16)

julia&gt; bench_dicttype(RedBlackHashMap, 100)
(size = 100, search_hit_ns = 35, search_miss_ns = 24)

julia&gt; bench_dicttype(RedBlackHashMap, 100_000)
(size = 100000, search_hit_ns = 69, search_miss_ns = 59)

julia&gt; bench_dicttype(RedBlackHashMap, 1_000_000)
(size = 1000000, search_hit_ns = 81, search_miss_ns = 71)</code></pre><p>Alas, anyone who&#39;s been using <code>Base.Dict</code> will have become accustomed to constant time lookups and inserts, while the <code>RedBlackHashMap</code> requires <span>$\log_{2}n$</span> time. Can we do better?</p><h2 id="Improving-on-\\mathcal{O}(\\log_{2}n)"><a class="docs-heading-anchor" href="#Improving-on-\\mathcal{O}(\\log_{2}n)">Improving on <span>$\mathcal{O}(\log_{2}n)$</span></a><a id="Improving-on-\\mathcal{O}(\\log_{2}n)-1"></a><a class="docs-heading-anchor-permalink" href="#Improving-on-\\mathcal{O}(\\log_{2}n)" title="Permalink"></a></h2><p><a href="../../contiguous/#PureFun.Contiguous.bitmap"><code>PureFun.Contiguous.bitmap</code></a> allows us to construct fast and compact dictionaries over integer keys, with lookups requiring a single memory access plus a couple of hardware-optimized bit-shift operations. The resulting dictionary is nearly as fast at indexing integer keys as a raw <code>Base.Vector</code>, but is sparse, requiring just one bit of extra storage for each key that is not present. The drawback is that we are limited to small keys. Still, we can construct a tiny version of C++&#39;s <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a><sup class="footnote-reference"><a id="citeref-addone" href="#footnote-addone">[addone]</a></sup>:</p><pre><code class="language-julia hljs">const BitMap = PureFun.Contiguous.bitmap(64)

@hashmap(BitMapHashMap,
         approx   = BitMap,
         exact    = PureFun.Association.List,
         hashfunc = x -&gt; 1 + hash(x) % 64)

test_dicttype(BitMapHashMap)</code></pre><pre><code class="nohighlight hljs">Test Summary:                                 | Pass  Total  Time
basic tests for Main.var&quot;##319&quot;.BitMapHashMap |    5      5  0.2s
</code></pre><p>Once again I ran the benchmarks locally:</p><pre><code class="language-julia hljs">julia&gt; bench_dicttype(BitMapHashMap, 10)
(size = 10, search_hit_ns = 23, search_miss_ns = 11)

julia&gt; bench_dicttype(BitMapHashMap, 100)
(size = 100, search_hit_ns = 24, search_miss_ns = 18)

julia&gt; bench_dicttype(BitMapHashMap, 100_000)
(size = 100000, search_hit_ns = 4171, search_miss_ns = 11417)</code></pre><p>For small collections, the <code>BitMapHashMap</code> provides lookup times comparable to <code>Base.Dict</code>, but if our collection grows much at all, lookup times devolve to linear in the number of elements, as the <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">pigeonhole principle</a> pushes most of the search down to the linked lists. We&#39;re calculating a full 64-bit hash, but we lose most of that information when we squeeze it into a BitMap that can only hold small numbers. What we need is a way to generalize the performance benefits of the <code>BitMap</code> to larger keys.</p><h2 id="Tries:-chaining-together-smaller-dictionaries"><a class="docs-heading-anchor" href="#Tries:-chaining-together-smaller-dictionaries">Tries: chaining together smaller dictionaries</a><a id="Tries:-chaining-together-smaller-dictionaries-1"></a><a class="docs-heading-anchor-permalink" href="#Tries:-chaining-together-smaller-dictionaries" title="Permalink"></a></h2><p>Chapter 10, (<span>$\S{10.3.1}$</span>) of <em>Purely Functional Data Structures</em> introduces another dictionary type, the <a href="https://en.wikipedia.org/wiki/Trie">trie</a>. It&#39;s described as &quot;a multiway tree where each edge is labelled with a character.&quot; In PureFun.jl, tries can be used not just with strings, but with any type of key that decomposes into a sequence of simpler keys.</p><p>Lookup and insertion times in tries are independent of the number of keys, and are instead linear in the length of keys. Tries in PureFun.jl use path compression, so in practice looking up well-distributed keys requires visiting a small number of nodes regardless of key length.</p><p>When implementing a trie, a critical question:</p><blockquote><p>... is how to represent edges leaving a node. Ordinarily, we would represent the children of a multiway node as a list of trees, but here we also need to represent the edge labels. Depending on the choice of base type and the expected density of the trie, we might represent the edges leaving a node as a vector, an association list, a binary search tree, or even, if the base type is itself a list or a string, another trie! We abstract away from the particular representation of these edge maps ...</p></blockquote><p><a href="../../dicts/#PureFun.Tries.@trie"><code>PureFun.Tries.@trie</code></a> constructs new trie types given an <code>edgemap</code> type.</p><pre><code class="language-julia hljs">@trie(RedBlackTrie,
      edgemap = PureFun.RedBlack.RBDict{Base.Order.ForwardOrdering})

test_dicttype(RedBlackTrie)</code></pre><pre><code class="nohighlight hljs">Test Summary:                                | Pass  Total  Time
basic tests for Main.var&quot;##319&quot;.RedBlackTrie |    5      5  0.8s
</code></pre><p>We can use any key type that decomposes into a sequence of simpler keys, for example we can use a trie to organize integer sequences stored as linked lists:</p><pre><code class="language-julia hljs">const ∅ = PureFun.Linked.List{Int}()

RedBlackTrie((1 ⇀ 2 ⇀ ∅     =&gt; &quot;inorder&quot;,
              3 ⇀ 2 ⇀ 1 ⇀ ∅ =&gt; &quot;reversed&quot;,
              2 ⇀ 1 ⇀ 3 ⇀ ∅ =&gt; &quot;random&quot;))</code></pre><pre><code class="nohighlight hljs">Main.var&quot;##319&quot;.RedBlackTrie{PureFun.Linked.NonEmpty{Int64}, String} with 3 entries:
  1, 2,  =&gt; &quot;inorder&quot;
  2, 1, 3,  =&gt; &quot;random&quot;
  3, 2, 1,  =&gt; &quot;reversed&quot;</code></pre><p>Because we started with already randomized string keys (which we expect to be nicely distributed), the <code>RedBlackTrie</code> can shine without need for a hash function:</p><pre><code class="language-julia hljs">julia&gt; bench_dicttype(RedBlackTrie, 10)
(size = 10, search_hit_ns = 40, search_miss_ns = 26)

julia&gt; bench_dicttype(RedBlackTrie, 100)
(size = 100, search_hit_ns = 55, search_miss_ns = 39)

julia&gt; bench_dicttype(RedBlackTrie, 100_000)
(size = 100000, search_hit_ns = 89, search_miss_ns = 68)

julia&gt; bench_dicttype(RedBlackTrie, 1_000_000)
(size = 1000000, search_hit_ns = 109, search_miss_ns = 86)</code></pre><h2 id="biterate:-iterating-over-sequences-of-bits"><a class="docs-heading-anchor" href="#biterate:-iterating-over-sequences-of-bits"><code>biterate</code>: iterating over sequences of bits</a><a id="biterate:-iterating-over-sequences-of-bits-1"></a><a class="docs-heading-anchor-permalink" href="#biterate:-iterating-over-sequences-of-bits" title="Permalink"></a></h2><p><code>@trie</code> takes, as an optional argument, a <code>keyfunc</code> that reinterprets the input key as a sequence of simpler keys. By default, <code>keyfunc</code> is equal to <code>codeunits</code> for <code>String</code> keys, in order to correctly handle strings with variable-width character encodings.</p><p><a href="../../contiguous/#PureFun.Contiguous.biterate"><code>PureFun.Contiguous.biterate</code></a>, which takes an integer key and efficiently<sup class="footnote-reference"><a id="citeref-biterate" href="#footnote-biterate">[biterate]</a></sup> reinterprets it as a sequence of smaller integers, is especially relevant to the current discussion. The resulting sequence can be thought of as vector indexes, and in keeping with Julia&#39;s convention of 1-based indexing, the iterated elements start at 1. In the following example, we iterate over the input 8 bits at a time, outputting sequences of integers in the range <span>$[1, 256]$</span> (since <span>$2^{8} == 256$</span>)</p><pre><code class="language-julia hljs">for i in PureFun.Contiguous.biterate(8, 19481210) println(i) end</code></pre><pre><code class="nohighlight hljs">123
67
42
2
1
1
1
1
</code></pre><p>We can use <code>biterate</code> to help us chain together <code>BitMap</code>s to store larger integer keys, we call the resulting structure a bitmapped trie or bitmapped array trie:</p><pre><code class="language-julia hljs">@trie(BitMapTrie,
      edgemap = PureFun.Contiguous.bitmap(64),
      keyfunc = PureFun.Contiguous.biterate(6))</code></pre><p>This dictionary type can only store integer keys, so instead of running it through the usual tests, we just run these ad hoc tests to make sure things are working:</p><pre><code class="language-julia hljs">bmt = BitMapTrie((0 =&gt; &quot;wee&quot;, 1 =&gt; &quot;hello&quot;, 2 =&gt; &quot;world&quot;))
@assert bmt[2] == &quot;world&quot;
@assert length(bmt) == 3</code></pre><p>In the worst case, a lookup in <code>BitMapTrie</code> takes 11 memory accesses, one for each chunk of bits that we use to represent the 64 bit input<sup class="footnote-reference"><a id="citeref-biteratelength" href="#footnote-biteratelength">[biteratelength]</a></sup>. But due to path compression, if our keys are spread out we&#39;ll only ever have to lookup a couple of the indexes before uniquely identifying a key. For that reason, when combined with a good hash function, <code>BitMapTrie</code> makes an ideal <code>approx</code> dictionary for a hash table:</p><pre><code class="language-julia hljs">@hashmap(HAMT,
         approx = BitMapTrie,
         exact  = PureFun.Association.List)

test_dicttype(HAMT)</code></pre><pre><code class="nohighlight hljs">Test Summary:                        | Pass  Total  Time
basic tests for Main.var&quot;##319&quot;.HAMT |    5      5  0.4s
</code></pre><pre><code class="language-julia hljs">julia&gt; bench_dicttype(HAMT, 10)
(size = 10, search_hit_ns = 31, search_miss_ns = 14)

julia&gt; bench_dicttype(HAMT, 100)
(size = 100, search_hit_ns = 42, search_miss_ns = 21)

julia&gt; bench_dicttype(HAMT, 100_000)
(size = 100000, search_hit_ns = 58, search_miss_ns = 49)

julia&gt; bench_dicttype(HAMT, 1_000_000)
(size = 1000000, search_hit_ns = 75, search_miss_ns = 49)</code></pre><p>The HAMT is described as a constant-time container, so why does it look like search times increase (gradually – notice that each of the last two steps are 1000x increases in number of elements) with the number of elements?</p><p>Our hash function maps all keys to hashes of the same length. As a result, the worst-case lookup time after having calculated the hash is in fact constant, defined by the total number of hops, 5 bits at a time, required to consume 64 bits<sup class="footnote-reference"><a id="citeref-caveat" href="#footnote-caveat">[caveat]</a></sup>.</p><p>But as we can see, in practice lookups are much faster than the theoretical worst-case due to the path compression in the tries. We only end up using as much of the hash as is necessary to uniquely identify a key. That number will grow slowly as we keep adding additional elements, and as a result the observed search times will slowly approach the theoretical worst-case.</p><h2 id="References-and-further-reading"><a class="docs-heading-anchor" href="#References-and-further-reading">References and further reading</a><a id="References-and-further-reading-1"></a><a class="docs-heading-anchor-permalink" href="#References-and-further-reading" title="Permalink"></a></h2><p>The idea of tries as bootstrapping a finite map over a simple type to a finite map over aggregate types is introduced in section 10.3.1 in <em>Purely Functional Data Structures</em>. Exercise 10.10 describes collapsing paths of nodes with only a single child into a single node, such that no node is both invalid and an only child. However, that exercise suggests achieving this by storing in each node the longest common prefix of the keys stored below. Trie path compression in PureFun.jl, on the other hand, follows the section &quot;Compressed trie with digit number&quot; in <a href="https://www.cise.ufl.edu/~sahni/dsaac/enrich/c16/tries.htm">these notes by Sartaj Sahni</a>, resulting in a much more compact (and as a result, performant) trie structure.</p><p>The Array Mapped Tree, the inspiration for <a href="../../contiguous/#PureFun.Contiguous.bitmap"><code>PureFun.Contiguous.bitmap</code></a>, is described in <a href="https://www.semanticscholar.org/paper/Fast-And-Space-Efficient-Trie-Searches-Bagwell/93a1fe7f226cfbc7cb2bceac39308a66c8aef0b0">Fast and Space Efficient Trie Searches</a>.</p><p>The idea behind <a href="../../contiguous/#PureFun.Contiguous.biterate"><code>PureFun.Contiguous.biterate</code></a>, iterating over several bits of an integer at a time, is presented in <a href="https://www.semanticscholar.org/paper/Ideal-Hash-Trees-Bagwell/4fc240d0d9e690cb9b0bcb2f8a5e5ca918b01410">Ideal Hash Trees</a>. That paper introduces the HAMT as it is described here.</p><p><a href="https://youtu.be/xz0Vh5BbBic">This presentation by @theVtuberCh</a> is a good introduction to Hash Array Mapped Tries and several related concepts and data structures.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-hashfuncs"><a class="tag is-link" href="#citeref-hashfuncs">hashfuncs</a><p>We can specify different hash functions to achieve a variety of           behaviors. For example, in <a href="https://hrdag.org/2013/03/07/hrdags-record-de-duplication/">near duplicate           detection</a>,           we utilize <em>locality-sensitive</em> hash functions, which hash           &quot;similar&quot; input values to the same output value, for           domain-specific definitions of &quot;similar.&quot; Given a           <a href="https://en.wikipedia.org/wiki/Soundex">soundex</a> implementation,           we could expand <code>RedBlackHashMap</code> into a dictionary of named           tuples indexed into &quot;blocks&quot; of similar records:</p><pre><code class="language-julia hljs">@hashmap(SoundexDict,
         approx   = RedBlackHashMap,
         exact    = RedBlackHashMap,
         hashfunc = x -&gt; soundex(x.lastname))</code></pre></li><li class="footnote" id="footnote-addone"><a class="tag is-link" href="#citeref-addone">addone</a>When taking the modulo to convert the hash to a valid key for the bitmap   we have to add 1, since the bitmaps expect keys in the range <span>$[1,2^{n}]$</span>   rather than <span>$[0,2^{n}-1]$</span></li><li class="footnote" id="footnote-biterate"><a class="tag is-link" href="#citeref-biterate">biterate</a><code>biterate</code> works by consuming its input a few bits at a time, and          interprets those bits as an integer (after adding a 1). It is          implemented in terms of bit-shifting operations and so is very          fast.</li><li class="footnote" id="footnote-biteratelength"><a class="tag is-link" href="#citeref-biteratelength">biteratelength</a>since 6 doesn&#39;t divide evenly into 64, the last index                produced by <code>biterate</code> will only have 4 bits and sit in the                range <span>$[1,16]$</span>. Also we can reduce the worst-case number of                memory accesses in this case by using a smaller key, such as                a 32-bit or 16-bit integer (<code>Int32</code> or <code>Int16</code>).</li><li class="footnote" id="footnote-caveat"><a class="tag is-link" href="#citeref-caveat">caveat</a>Barring a hash collision, which is extremely unlikely outside of an        adversarial attack, as we are using the full 64 bits of the hash</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../suffixes/">« Generating Suffixes</a><a class="docs-footer-nextpage" href="../estimating-pi/">Estimating π »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 18 December 2022 17:15">Sunday 18 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
